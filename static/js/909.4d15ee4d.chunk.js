"use strict";(self.webpackChunkreact_speedcubing_timer=self.webpackChunkreact_speedcubing_timer||[]).push([[909],{909:(t,e,i)=>{i.r(e),i.d(e,{Cube3D:()=>Q,PG3D:()=>ct,T3I:()=>s.S,Twisty3DScene:()=>lt,cube3DShim:()=>ut,pg3dShim:()=>pt});var s=i(75),n=i(263),r=i(546);function o(t){return t*t*t*(10-t*(15-6*t))}var a=new s.T,h=new s.V9({color:new s.Q1(6710886).convertLinearToSRGB()}),c=new s.V9({color:new s.Q1(13421772).convertLinearToSRGB(),side:s.hs,transparent:!0,opacity:.75}),l=new s.V9({visible:!1}),u=new s.V9({color:4513228}),p=new s.V9({color:4513228,side:s.hs,transparent:!0,opacity:.5}),d=new s.V9({color:16776618}),f=new s.V9({color:16775545,side:s.hs,transparent:!0,opacity:.5}),k=new s.V9({color:15911883}),m=new s.V9({color:15911883,side:s.hs,transparent:!0,opacity:.5}),w=class{constructor(t,e,i,n,o,a){(0,r.Mu)(this,"stickerMaterial"),(0,r.Mu)(this,"hintStickerMaterial"),this.vector=t,this.fromZ=e,this.color=i,this.dimColor=n,this.hintOpacityScale=o;const w=new s.Q1(i).convertLinearToSRGB(),S=new s.Q1(n).convertLinearToSRGB();this.stickerMaterial={regular:new s.V9({color:w,side:s.hB}),dim:new s.V9({color:S,side:s.hB}),oriented:u,experimentalOriented2:d,ignored:h,invisible:l,mystery:k},this.hintStickerMaterial={regular:new s.V9({color:new s.Q1(a?.hintColor??i).convertLinearToSRGB(),side:s.hs,transparent:!0,opacity:.5*o}),dim:new s.V9({color:new s.Q1(a?.hintDimColor??n).convertLinearToSRGB(),side:s.hs,transparent:!0,opacity:.5*o}),oriented:p,experimentalOriented2:f,ignored:c,invisible:l,mystery:m}}},S=[new w(new s.Pq(0,1,0),new s.O9(-s.DD/4,0,0),16777215,14540253,1.25),new w(new s.Pq(-1,0,0),new s.O9(0,-s.DD/4,0),16750848,8934656,1,{hintDimColor:8930304}),new w(new s.Pq(0,0,1),new s.O9(0,0,0),65280,34816,1,{hintDimColor:39168}),new w(new s.Pq(1,0,0),new s.O9(0,s.DD/4,0),16711680,6684672,1,{hintDimColor:6684672}),new w(new s.Pq(0,0,-1),new s.O9(0,s.DD/2,0),2254591,1127304,.75,{hintDimColor:6246}),new w(new s.Pq(0,-1,0),new s.O9(s.DD/4,0,0),16776960,8947712,1.25,{hintDimColor:14540032})],M={U:0,L:1,F:2,R:3,B:4,D:5},y={U:M.U,u:M.U,Uw:M.U,Uv:M.U,y:M.U,L:M.L,l:M.L,Lw:M.L,Lv:M.L,M:M.L,F:M.F,f:M.F,Fw:M.F,Fv:M.F,S:M.F,z:M.F,R:M.R,r:M.R,Rw:M.R,Rv:M.R,x:M.R,B:M.B,b:M.B,Bw:M.B,Bv:M.B,D:M.D,d:M.D,Dw:M.D,Dv:M.D,E:M.D},D=.503,g=1,v=1.45,x={showMainStickers:!0,hintFacelets:"floating",showFoundation:!0,experimentalStickeringMask:void 0,foundationSprite:null,hintSprite:null,initialHintFaceletsAnimation:"auto",faceletScale:"auto"};function R(t){return"undefined"===typeof t.faceletScale||"auto"===t.faceletScale?.85:t.faceletScale}var E=new s.V9({color:0,opacity:1,transparent:!0}),b=new s.V9({color:0,opacity:.3,transparent:!0}),F=class{constructor(t,e,i){(0,r.Mu)(this,"matrix"),(0,r.Mu)(this,"stickerFaces"),this.orbit=t;const n="string"===typeof e?e.split(""):e;this.stickerFaces=n.map((t=>M[t])),this.matrix=new s.kn,this.matrix.setPosition(A[t]),this.matrix.premultiply((new s.kn).makeRotationFromQuaternion(i))}};function C(t,e){return(new s.PT).setFromAxisAngle(t,s.DD*e/4)}var T={O:new s.Pq(0,0,0),U:new s.Pq(0,-1,0),L:new s.Pq(1,0,0),F:new s.Pq(0,0,-1),R:new s.Pq(-1,0,0),B:new s.Pq(0,0,1),D:new s.Pq(0,1,0)},A={EDGES:new s.Pq(0,1,1),CORNERS:new s.Pq(1,1,1),CENTERS:new s.Pq(0,1,0)},z={EDGES:[0,1].map((t=>(new s.kn).makeRotationAxis(A.EDGES.clone().normalize(),-t*s.DD/2))),CORNERS:[0,1,2].map((t=>(new s.kn).makeRotationAxis(A.CORNERS.clone().normalize(),-t*s.DD/3))),CENTERS:[0,1,2,3].map((t=>(new s.kn).makeRotationAxis(A.CENTERS.clone().normalize(),-t*s.DD/4)))},P=[M.U,M.F,M.R],U={EDGES:[new F("EDGES","UF",C(T.O,0)),new F("EDGES","UR",C(T.U,3)),new F("EDGES","UB",C(T.U,2)),new F("EDGES","UL",C(T.U,1)),new F("EDGES","DF",C(T.F,2)),new F("EDGES","DR",C(T.F,2).premultiply(C(T.D,1))),new F("EDGES","DB",C(T.F,2).premultiply(C(T.D,2))),new F("EDGES","DL",C(T.F,2).premultiply(C(T.D,3))),new F("EDGES","FR",C(T.U,3).premultiply(C(T.R,3))),new F("EDGES","FL",C(T.U,1).premultiply(C(T.R,3))),new F("EDGES","BR",C(T.U,3).premultiply(C(T.R,1))),new F("EDGES","BL",C(T.U,1).premultiply(C(T.R,1)))],CORNERS:[new F("CORNERS","UFR",C(T.O,0)),new F("CORNERS","URB",C(T.U,3)),new F("CORNERS","UBL",C(T.U,2)),new F("CORNERS","ULF",C(T.U,1)),new F("CORNERS","DRF",C(T.F,2).premultiply(C(T.D,1))),new F("CORNERS","DFL",C(T.F,2).premultiply(C(T.D,0))),new F("CORNERS","DLB",C(T.F,2).premultiply(C(T.D,3))),new F("CORNERS","DBR",C(T.F,2).premultiply(C(T.D,2)))],CENTERS:[new F("CENTERS","U",C(T.O,0)),new F("CENTERS","L",C(T.R,3).premultiply(C(T.U,1))),new F("CENTERS","F",C(T.R,3)),new F("CENTERS","R",C(T.R,3).premultiply(C(T.D,1))),new F("CENTERS","B",C(T.R,3).premultiply(C(T.D,2))),new F("CENTERS","D",C(T.R,2))]},O=1/3,G={EDGES:[[[0,4,6],[0,4,5]],[[3,5,7],[0,7,5]],[[2,4,8],[0,10,5]],[[1,3,7],[0,1,5]],[[2,4,2],[2,4,3]],[[3,5,1],[2,7,3]],[[0,4,0],[2,10,3]],[[1,3,1],[2,1,3]],[[3,5,4],[3,6,4]],[[1,3,4],[1,2,4]],[[1,9,4],[1,8,4]],[[3,11,4],[3,0,4]]],CORNERS:[[[0,5,6],[0,5,5],[0,6,5]],[[3,5,8],[0,8,5],[0,9,5]],[[2,3,8],[0,11,5],[0,0,5]],[[1,3,6],[0,2,5],[0,3,5]],[[3,5,2],[2,6,3],[2,5,3]],[[2,3,2],[2,3,3],[2,2,3]],[[1,3,0],[2,0,3],[2,11,3]],[[0,5,0],[2,9,3],[2,8,3]]],CENTERS:[[[0,4,7]],[[0,1,4]],[[0,4,4]],[[0,7,4]],[[0,10,4]],[[0,4,1]]]},B=null;function V(){const t=new s.Lo,e=.5;return t.setAttribute("position",new s.TH(new Float32Array([e,e,0,-.5,e,0,e,-.5,0,-.5,e,0,-.5,-.5,0,e,-.5,0]),3)),t.setAttribute("uv",new s.TH(new Float32Array([1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,1,1]),2)),t}var L,H,q,N,I,j,W=null;var Q=(j=class extends s.B6{constructor(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),(0,r.VK)(this,H),(0,r.VK)(this,N),(0,r.Mu)(this,"kpuzzleFaceletInfo"),(0,r.Mu)(this,"pieces",{}),(0,r.Mu)(this,"options"),(0,r.Mu)(this,"experimentalHintStickerMeshes",[]),(0,r.Mu)(this,"experimentalFoundationMeshes",[]),(0,r.Mu)(this,"setSpriteURL"),(0,r.Mu)(this,"sprite",new Promise((t=>{this.setSpriteURL=e=>{a.load(e,t)}}))),(0,r.Mu)(this,"setHintSpriteURL"),(0,r.Mu)(this,"hintSprite",new Promise((t=>{this.setHintSpriteURL=e=>{a.load(e,t)}}))),(0,r.VK)(this,L,null),this.kpuzzle=t,this.scheduleRenderCallback=e,this.options={...x},Object.assign(this.options,i),"3x3x3"!==this.kpuzzle.name())throw new Error(`Invalid puzzle for this Cube3D implementation: ${this.kpuzzle.name()}`);i.foundationSprite&&this.setSprite(i.foundationSprite),i.hintSprite&&this.setHintSprite(i.hintSprite),this.kpuzzleFaceletInfo={};for(const s in U){const t=[];this.kpuzzleFaceletInfo[s]=t,this.pieces[s]=U[s].map(this.createCubie.bind(this,s,t))}this.scale.set(O,O,O),this.options.experimentalStickeringMask&&this.setStickeringMask(this.options.experimentalStickeringMask),(0,r.jq)(this,N,I).call(this),this.options.faceletScale&&this.experimentalSetFaceletScale(this.options.faceletScale)}setSprite(t){this.sprite=t}setHintSprite(t){this.hintSprite=t}experimentalSetStickerSpriteURL(t){this.setSpriteURL(t)}experimentalSetHintStickerSpriteURL(t){this.setHintSpriteURL(t)}setStickeringMask(t){if("picture"!==t.specialBehaviour){this.options.experimentalStickeringMask=t;for(const[e,i]of Object.entries(t.orbits))for(let t=0;t<i.pieces.length;t++){const s=i.pieces[t];if(s){const i=this.kpuzzleFaceletInfo[e][t];for(let t=0;t<i.length;t++){const e=s.facelets[t];if(e){const s=i[t],n="string"===typeof e?e:e?.mask;s.facelet.material=S[s.faceIdx].stickerMaterial[n];const r="string"===typeof e?n:e.hintMask??n;s.hintFacelet&&(s.hintFacelet.material=S[s.faceIdx].hintStickerMaterial[r])}}}}this.scheduleRenderCallback&&this.scheduleRenderCallback()}else for(const e of Object.values(this.kpuzzleFaceletInfo))for(const t of e)for(const e of t){e.facelet.material=l;const{hintFacelet:t}=e;t&&(t.material=l)}}experimentalUpdateOptions(t){if("showMainStickers"in t)throw new Error("Unimplemented");const e=t.showFoundation;if("undefined"!==typeof e&&this.options.showFoundation!==e){this.options.showFoundation=e;for(const t of this.experimentalFoundationMeshes)t.visible=e}const i=t.hintFacelets;if("undefined"!==typeof i&&this.options.hintFacelets!==i&&s.yu[i]){this.options.hintFacelets=i;for(const t of this.experimentalHintStickerMeshes)t.visible="floating"===i;this.scheduleRenderCallback()}const{experimentalStickeringMask:n}=t;"undefined"!==typeof n&&(this.options.experimentalStickeringMask=n,this.setStickeringMask(n),this.scheduleRenderCallback());const{faceletScale:r}=t;"undefined"!==typeof r&&this.experimentalSetFaceletScale(r)}onPositionChange(t){const e=t.pattern;for(const i in U){const n=U[i];for(let t=0;t<n.length;t++){const s=e.patternData[i].pieces[t];this.pieces[i][s].matrix.copy(U[i][t].matrix),this.pieces[i][s].matrix.multiply(z[i][e.patternData[i].orientation[t]])}for(const r of t.movesInProgress){const t=r.move,o=S[y[t.family]].vector,a=(new s.kn).makeRotationAxis(o,-this.ease(r.fraction)*r.direction*t.amount*s.DD/4);for(let s=0;s<n.length;s++){const n=this.kpuzzle.moveToTransformation(t.modified({amount:1}));if(s!==n.transformationData[i].permutation[s]||0!==n.transformationData[i].orientationDelta[s]){const t=e.patternData[i].pieces[s];this.pieces[i][t].matrix.premultiply(a)}}}}this.scheduleRenderCallback()}createCubie(t,e,i,n){const r=[];e.push(r);const o=new s.YJ;if(this.options.showFoundation){const t=this.createCubieFoundation();o.add(t),this.experimentalFoundationMeshes.push(t)}for(let a=0;a<i.stickerFaces.length;a++){const e=this.createSticker(S[P[a]],S[i.stickerFaces[a]],!1),h={faceIdx:i.stickerFaces[a],facelet:e};if(o.add(e),"floating"===this.options.hintFacelets){const t=this.createSticker(S[P[a]],S[i.stickerFaces[a]],!0);o.add(t),h.hintFacelet=t,this.experimentalHintStickerMeshes.push(t)}if("picture"===this.options.experimentalStickeringMask?.specialBehaviour&&G[t]&&G[t][n]&&G[t][n][a]){const[e,r,h]=G[t][n][a];(async()=>{const t=async t=>{const n=await(t?this.hintSprite:this.sprite),c=this.createSticker(S[P[a]],S[i.stickerFaces[a]],t);c.material=new s.V9({map:n,side:t?s.hs:s.$E,transparent:!0});const l=r/12,u=(r+1)/12,p=h/9,d=(h+1)/9;let f=new s.I9(l,p),k=new s.I9(l,d),m=new s.I9(u,d),w=new s.I9(u,p);switch(e){case 1:[f,k,m,w]=[k,m,w,f];break;case 2:[f,k,m,w]=[m,w,f,k];break;case 3:[f,k,m,w]=[w,f,k,m]}c.geometry.setAttribute("uv",new s.TH(new Float32Array([m.x,m.y,k.x,k.y,w.x,w.y,k.x,k.y,f.x,f.y,w.x,w.y]),2)),o.add(c)};t(!0),t(!1)})()}r.push(h)}return o.matrix.copy(i.matrix),o.matrixAutoUpdate=!1,this.add(o),o}createCubieFoundation(){const t=B??(B=new s.iN(g,g,g));return new s.e(t,"picture"===this.options.experimentalStickeringMask?.specialBehaviour?E:b)}createSticker(t,e,i){const n="picture"===this.options.experimentalStickeringMask?.specialBehaviour?V():i?(0,r.jq)(this,H,q).call(this):W??(W=V()),o=new s.e(n,i?e.hintStickerMaterial.regular:e.stickerMaterial.regular);return o.setRotationFromEuler(t.fromZ),o.position.copy(t.vector),o.position.multiplyScalar(i?"picture"===this.options.experimentalStickeringMask?.specialBehaviour?2:v:D),o.scale.setScalar(R(this.options)),o}experimentalSetFoundationOpacity(t){this.experimentalFoundationMeshes[0].material.opacity=t}experimentalSetFaceletScale(t){this.options.faceletScale=t;for(const e of Object.values(this.kpuzzleFaceletInfo))for(const t of e)for(const e of t)e.facelet.scale.setScalar(R(this.options)),e.hintFacelet?.scale.setScalar(R(this.options))}ease(t){return o(t)}},L=new WeakMap,H=new WeakSet,q=function(){return(0,r.S7)(this,L)??(0,r.OV)(this,L,V())},N=new WeakSet,I=function(){if("none"===this.options.initialHintFaceletsAnimation||"always"!==this.options.initialHintFaceletsAnimation&&(0,s.qC)())return;const t=v-D;(0,r.jq)(this,H,q).call(this).translate(0,0,-t),setTimeout((()=>{const e=performance.now();let i=0;const s=()=>{const n=performance.now()-e,o=(a=n/1e3)*(2-a)*t;var a;(0,r.jq)(this,H,q).call(this).translate(0,0,o-i),i=o,n<1e3&&(requestAnimationFrame(s),this.scheduleRenderCallback?.())};s()}),500)},j),J=new s.V9({side:s.$E,color:0}),K=new s.V9({visible:!1}),$=new s.V9({vertexColors:!0});function _(t,e,i){return Math.hypot(t[3*e]-t[3*i],t[3*e+1]-t[3*i+1],t[3*e+2]-t[3*i+2])}function Y(t,e,i,s){const n=_(t,e,i),r=_(t,i,s),o=_(t,e,s),a=(n+r+o)/2;return Math.sqrt(a*(a-n)*(a-r)*(a-o))}function Z(t){let e=0;for(let i=2;3*i<t.length;i++)e+=Y(t,0,1,i);return e}function X(t){const e=function(t,e){const i=new Array(3);return i[0]=t[1]*e[2]-t[2]*e[1],i[1]=t[2]*e[0]-t[0]*e[2],i[2]=t[0]*e[1]-t[1]*e[0],i}([t[3]-t[0],t[4]-t[1],t[5]-t[2]],[t[6]-t[3],t[7]-t[4],t[8]-t[5]]);return function(t){const e=Math.hypot(t[0],t[1],t[2]);return t[0]/=e,t[1]/=e,t[2]/=e,t}(e)}var tt,et,it,st,nt=class{constructor(t,e){(0,r.Mu)(this,"pos"),(0,r.Mu)(this,"ipos"),(0,r.Mu)(this,"vertices"),(0,r.Mu)(this,"colors"),(0,r.Mu)(this,"uvs"),(0,r.Mu)(this,"ind"),this.sz=t,this.tm=e,this.vertices=new Float32Array(9*t),this.uvs=void 0,this.colors=new Uint8Array(18*t),this.ind=new Uint8Array(t),this.pos=0,this.ipos=0}add(t,e,i){this.vertices[this.pos]=t[3*e+0],this.vertices[this.pos+1]=t[3*e+1],this.vertices[this.pos+2]=t[3*e+2],this.colors[this.pos]=i>>16,this.colors[this.pos+1]=i>>8&255,this.colors[this.pos+2]=255&i,this.pos+=3}addUncolored(t,e){this.vertices[this.pos]=t[3*e+0],this.vertices[this.pos+1]=t[3*e+1],this.vertices[this.pos+2]=t[3*e+2],this.pos+=3}setind(t){this.ind[this.ipos++]=t}makePoly(t,e,i){const s=t;for(let n=1;3*(n+1)<s.length;n++)this.add(s,0,e),this.add(s,n,e),this.add(s,n+1,e),this.setind(i)}setAttributes(t){t.setAttribute("position",new s.TH(this.vertices,3));const e=this.colors.subarray(0,9*this.sz);t.setAttribute("color",new s.TH(e,3,!0))}makeGroups(t){t.clearGroups();for(let e=0;e<this.ipos;){const i=e++,s=this.ind[i];for(;this.ind[e]===s;)e++;t.addGroup(3*i,3*(e-i),s)}}saveOriginalColors(){this.colors.copyWithin(this.pos,0,this.pos)}},rt=class{constructor(t,e,i,n){(0,r.Mu)(this,"origColor"),(0,r.Mu)(this,"origColorStickeringMask"),(0,r.Mu)(this,"faceColor"),(0,r.Mu)(this,"texturePtr"),(0,r.Mu)(this,"twistVal",-1),(0,r.Mu)(this,"stickerStart"),(0,r.Mu)(this,"stickerEnd"),(0,r.Mu)(this,"hintStart"),(0,r.Mu)(this,"hintEnd"),(0,r.Mu)(this,"foundationStart"),(0,r.Mu)(this,"foundationEnd"),(0,r.Mu)(this,"isDup"),(0,r.Mu)(this,"faceNum"),this.isDup=!!e.isDup,this.faceNum=e.face,this.stickerStart=t.ipos;const o=new s.Q1(e.color).getHex();this.origColor=o,this.origColorStickeringMask=o,n?.stickeringMask&&this.setStickeringMask(t,n.stickeringMask),this.faceColor=o;const a=this.stickerCoords(e.coords,i);t.makePoly(a,this.faceColor,this.isDup?4:0),this.stickerEnd=t.ipos}stickerCoords(t,e){return function(t,e){const i=[],s=new Array(3),n=new Array(3);for(let r=1;r<10;r++){for(let o=0;o<t.length;o+=3){const r=(o+t.length-3)%t.length,a=(o+3)%t.length;for(let e=0;e<3;e++)s[e]=t[r+e]-t[o+e],n[e]=t[a+e]-t[o+e];const h=Math.hypot(s[0],s[1],s[2]),c=Math.hypot(n[0],n[1],n[2]);for(let t=0;t<3;t++)s[t]/=h,n[t]/=c;const l=s[0]*n[0]+s[1]*n[1]+s[2]*n[2],u=e/Math.sqrt(1-l*l);for(let e=0;e<3;e++)i[o+e]=t[o+e]+(s[e]+n[e])*u}let r=!0;for(let e=0;r&&e<i.length;e+=3){const s=(e+3)%t.length;let n=0;for(let r=0;r<3;r++)n+=(t[s+r]-t[e+r])*(i[s+r]-i[e+r]);n<=0&&(r=!1)}if(r)return i;e/=2}return t}(t.slice(),e)}hintCoords(t,e,i,s){t=this.stickerCoords(t,i),s=s.slice();for(let r=0;r<3;r++)s[r]*=.5*e;const n=new Array(t.length);for(let r=0;3*r<t.length;r++){const e=t.length/3-1-r;n[3*r]=t[3*e]+s[0],n[3*r+1]=t[3*e+1]+s[1],n[3*r+2]=t[3*e+2]+s[2]}return n}foundationCoords(t){const e=t.slice();for(let i=0;i<t.length;i++)e[i]=.995*t[i];return e}addHint(t,e,i,s,n,r){this.hintStart=t.ipos;const o=this.hintCoords(e.coords,s,n,r);t.makePoly(o,this.faceColor,i&&!this.isDup?2:4),this.hintEnd=t.ipos}addFoundation(t,e,i){this.foundationStart=t.ipos;const s=this.foundationCoords(e.coords);t.makePoly(s,i,this.isDup?4:6),this.foundationEnd=t.ipos}setHintStickers(t,e){const i=this.isDup||!e?4:2;for(let s=this.hintStart;s<this.hintEnd;s++)t.ind[s]=i|1&t.ind[s]}setStickeringMask(t,e){let i=0;switch(e){case"regular":case"invisible":i=this.origColor;break;case"dim":i=16777215===this.origColor?14540253:new s.Q1(this.origColor).multiplyScalar(.5).getHex();break;case"oriented":i=4513228;break;case"experimentalOriented2":i=16776618;break;case"ignored":i=4473924;break;case"mystery":i=15911883}this.origColorStickeringMask=i;for(let s=9*this.stickerStart;s<9*this.stickerEnd;s+=3)t.colors[t.pos+s]=i>>16,t.colors[t.pos+s+1]=i>>8&255,t.colors[t.pos+s+2]=255&i;for(let s=9*this.hintStart;s<9*this.hintEnd;s+=3)t.colors[t.pos+s]=i>>16,t.colors[t.pos+s+1]=i>>8&255,t.colors[t.pos+s+2]=255&i;this.setHintStickers(t,"invisible"!==e&&!this.isDup)}addUVs(t){const e=t.uvs,i=t.vertices,s=new Array(3);for(let n=3*this.stickerStart;n<3*this.stickerEnd;n++){s[0]=i[3*n],s[1]=i[3*n+1],s[2]=i[3*n+2];const r=t.tm.getuv(this.faceNum,s);e[2*n]=r[0],e[2*n+1]=r[1]}for(let n=3*this.hintStart;n<3*this.hintEnd;n++){s[0]=i[3*n],s[1]=i[3*n+1],s[2]=i[3*n+2];const r=t.tm.getuv(this.faceNum,s);e[2*n]=r[0],e[2*n+1]=r[1]}}setTexture(t,e){if(this.texturePtr===e)return 0;this.texturePtr=e;const i=6*t.sz;return t.uvs.copyWithin(6*this.stickerStart,6*e.stickerStart+i,6*e.stickerEnd+i),t.uvs.copyWithin(6*this.hintStart,6*e.hintStart+i,6*e.hintEnd+i),1}setColor(t,e){const i=e.origColorStickeringMask;if(this.faceColor!==i){this.faceColor=i;const s=t.pos;return t.colors.copyWithin(9*this.stickerStart,9*e.stickerStart+s,9*e.stickerEnd+s),t.colors.copyWithin(9*this.hintStart,9*e.hintStart+s,9*e.hintEnd+s),1}return 0}},ot=class{constructor(t,e,i){(0,r.Mu)(this,"cubie"),(0,r.Mu)(this,"geo"),this.cubie=new s.YJ;const o=t.coords,a=new nt(o.length/3-2,e);for(let s=1;3*s+3<o.length;s++)a.addUncolored(o,0),a.addUncolored(o,s),a.addUncolored(o,s+1);this.geo=new s.Lo,a.setAttributes(this.geo);const h=new s.e(this.geo,K);h.userData.quantumMove=i.notationMapper.notationToExternal(new n.yU(t.name)),this.cubie.scale.setScalar(.99),this.cubie.add(h)}},at=class{constructor(t){(0,r.Mu)(this,"axis"),(0,r.Mu)(this,"order");const e=t.coordinates;this.axis=new s.Pq(e[0],e[1],e[2]),this.order=t.order}},ht=.5,ct=(st=class extends s.B6{constructor(t,e,i){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:{};if(super(),(0,r.VK)(this,et),(0,r.Mu)(this,"stickers"),(0,r.Mu)(this,"axesInfo"),(0,r.Mu)(this,"stickerTargets",[]),(0,r.Mu)(this,"controlTargets",[]),(0,r.Mu)(this,"movingObj"),(0,r.Mu)(this,"filler"),(0,r.Mu)(this,"foundationBound"),(0,r.Mu)(this,"fixedGeo"),(0,r.Mu)(this,"lastPos"),(0,r.Mu)(this,"lastMoveTransformation"),(0,r.Mu)(this,"hintMaterial"),(0,r.Mu)(this,"stickerMaterial"),(0,r.Mu)(this,"materialArray1"),(0,r.Mu)(this,"materialArray2"),(0,r.Mu)(this,"textured",!1),(0,r.Mu)(this,"showHintStickers",!1),(0,r.Mu)(this,"showFoundations",!1),(0,r.Mu)(this,"hintMaterialDisposable"),(0,r.Mu)(this,"stickerMaterialDisposable"),(0,r.VK)(this,tt,!1),(0,r.Mu)(this,"isPG3DForTwisty3DPuzzleWrapper"),this.scheduleRenderCallback=t,this.kpuzzle=e,this.stickerDat=i,this.faceletScale=h,this.params=c,0===i.stickers.length)throw Error("Reuse of stickerdat from pg; please don't do that.");this.hintMaterial=new s.V9({vertexColors:!0,transparent:!0,opacity:.5}),this.hintMaterialDisposable=!0,this.stickerMaterial=$,this.stickerMaterialDisposable=!1,this.axesInfo={};const l=this.stickerDat.axis;for(const s of l)this.axesInfo[s.quantumMove.family]=new at(s);const u=this.stickerDat.stickers;this.stickers={},this.materialArray1=new Array(8),this.materialArray2=new Array(8),this.showFoundation(n),n=!0;let p=0;for(const s of u){p+=3*(s.coords.length/3-2)}const d=new nt(p,i.textureMapper),f=[];let k=0;for(const s of i.faces)f.push(X(s.coords)),k+=Z(s.coords);const m="auto"!==h?h*h:.71;let w=0;for(const s of u)s.isDup||w++;const S=Math.sqrt(k/w)*(1-Math.sqrt(m))/2;for(const r of u){const t=r.orbit,e=r.ord,i=r.ori;this.stickers[t]||(this.stickers[t]=[]),this.stickers[t][i]||(this.stickers[t][i]=[]);const n={};c.stickeringMask&&(n.stickeringMask=(0,s.FP)(c.stickeringMask,t,e,i,!1));const o=new rt(d,r,S,n);this.stickers[t][i][e]=o}this.showHintStickers=o,o=!0;for(const s of u){const t=s.orbit,e=s.ord,i=s.ori;this.stickers[t][i][e].addHint(d,s,o,a,S,f[s.face])}this.foundationBound=d.ipos;for(const s of u){const t=s.orbit,e=s.ord,i=s.ori;n&&this.stickers[t][i][e].addFoundation(d,s,0)}const M=new s.Lo;d.setAttributes(M),d.makeGroups(M);const y=new s.e(M,this.materialArray1);y.scale.set(ht,ht,ht),this.add(y);const D=new s.e(M,this.materialArray2);D.scale.set(ht,ht,ht),this.add(D);const g=this.stickerDat.faces;this.movingObj=D,this.fixedGeo=M,this.filler=d;for(const s of g){const t=new ot(s,i.textureMapper,this.stickerDat);t.cubie.scale.set(ht,ht,ht),this.add(t.cubie),this.controlTargets.push(t.cubie.children[0])}d.saveOriginalColors(),i.stickers=[],this.updateMaterialArrays()}dispose(){this.fixedGeo&&this.fixedGeo.dispose(),this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterial=$,this.stickerMaterialDisposable=!1),this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterial=$,this.hintMaterialDisposable=!1)}experimentalGetStickerTargets(){return this.stickerTargets}experimentalGetControlTargets(){return this.controlTargets}getClosestMoveToAxis(t,e){let i=null,n=0,o=t=>t;switch(e.depth){case"secondSlice":o=t=>t.modified({innerLayer:2});break;case"rotation":o=t=>t.modified({family:`${t.family}v`})}for(const a of this.stickerDat.axis){const e=t.dot(new s.Pq(...a.coordinates));if(e>n){const t=this.stickerDat.notationMapper.notationToExternal(o(a.quantumMove));if(!t)continue;(0,r.jq)(this,et,it).call(this,t)&&(n=e,i=t)}}if(!i)return null;e.invert&&(i=i.invert());return{move:i,order:this.kpuzzle.moveToTransformation(i).repetitionOrder()}}setStickeringMask(t){if(this.params.stickeringMask=t,"picture"!==t.specialBehaviour)for(const e of this.kpuzzle.definition.orbits){const{numPieces:i,numOrientations:n}=e;for(let r=0;r<i;r++)for(let i=0;i<n;i++){const n=(0,s.FP)(t,e.orbitName,r,i,!1),o=this.stickers[e.orbitName][i][r];this.textured&&this.hintMaterialDisposable&&"invisible"===n||o.setStickeringMask(this.filler,n)}}(0,r.OV)(this,tt,!0),this.lastPos&&this.onPositionChange(this.lastPos)}onPositionChange(t){const e=t.pattern.experimentalToTransformation();if(!e)throw new Error("indistinguishable pieces are not supported by PG3D yet");const i=new s.O9;this.movingObj.rotation.copy(i);let n=0;const o=this.filler,a=o.ind;if(!this.lastPos||(0,r.S7)(this,tt)||!this.lastPos.pattern.experimentalToTransformation().isIdentical(e)){for(const t in this.stickers){const i=this.stickers[t],s=e.transformationData[t],r=i.length;if(1===r){const t=i[0];for(let e=0;e<t.length;e++){const i=s.permutation[e];this.textured?n+=t[e].setTexture(o,t[i]):n+=t[e].setColor(o,t[i])}}else for(let t=0;t<r;t++){const e=i[t];for(let a=0;a<e.length;a++){const h=(t+r-s.orientationDelta[a])%r,c=s.permutation[a];this.textured?n+=e[a].setTexture(o,i[h][c]):n+=e[a].setColor(o,i[h][c])}}}this.lastPos=t}let h=0;for(const r of t.movesInProgress){const t=r.move,e=this.stickerDat.unswizzle(t);if(!e)return;const i=t;let n;try{n=this.kpuzzle.moveToTransformation(i.modified({amount:1}))}catch(c){const t=this.stickerDat.notationMapper.notationToInternal(i);if(t){const e=this.stickerDat.notationMapper.notationToExternal(t.modified({amount:1}));e&&(n=this.kpuzzle.moveToTransformation(e))}if(!n)throw console.log(c),c}const o=this.axesInfo[e.family],l=o.axis,u=-this.ease(r.fraction)*r.direction*e.amount*s.DD/o.order;if(this.movingObj.rotateOnAxis(l,u),this.lastMoveTransformation!==n){for(const t in this.stickers){const e=this.stickers[t],i=e.length,s=n.transformationData[t];for(let t=0;t<i;t++){const i=e[t];for(let t=0;t<i.length;t++){const e=i[t];let n=0;if(s.permutation[t]===t&&0===s.orientationDelta[t]||(n=1),n!==e.twistVal){if(n){for(let t=e.stickerStart;t<e.stickerEnd;t++)a[t]|=1;for(let t=e.hintStart;t<e.hintEnd;t++)a[t]|=1;for(let t=e.foundationStart;t<e.foundationEnd;t++)a[t]|=1}else{for(let t=e.stickerStart;t<e.stickerEnd;t++)a[t]&=-2;for(let t=e.hintStart;t<e.hintEnd;t++)a[t]&=-2;for(let t=e.foundationStart;t<e.foundationEnd;t++)a[t]&=-2}e.twistVal=n,h++}}}}this.lastMoveTransformation=n}}((0,r.S7)(this,tt)||h)&&this.filler.makeGroups(this.fixedGeo),((0,r.S7)(this,tt)||n)&&(this.textured&&(this.fixedGeo.getAttribute("uv").addUpdateRange(0,6*this.foundationBound),this.fixedGeo.getAttribute("uv").needsUpdate=!0),!(0,r.S7)(this,tt)&&this.textured||(this.fixedGeo.getAttribute("color").addUpdateRange(0,9*this.foundationBound),this.fixedGeo.getAttribute("color").needsUpdate=!0)),this.scheduleRenderCallback(),(0,r.OV)(this,tt,!1)}ease(t){return o(t)}showHintFacelets(t){this.showHintStickers=t}updateMaterialArrays(){for(let t=0;t<8;t++)this.materialArray1[t]=K,this.materialArray2[t]=K;this.materialArray1[0]=this.stickerMaterial,this.materialArray2[1]=this.stickerMaterial,this.showHintStickers?(this.materialArray1[2]=this.hintMaterial,this.materialArray2[3]=this.hintMaterial):(this.materialArray1[2]=K,this.materialArray2[3]=K),this.showFoundations?(this.materialArray1[6]=J,this.materialArray2[7]=J):(this.materialArray1[6]=K,this.materialArray2[7]=K)}showFoundation(t){this.showFoundations=t}setHintStickerOpacity(t){this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),0===t?this.hintMaterial=K:1===t?this.hintMaterial=this.stickerMaterial:(this.hintMaterial=new s.V9({vertexColors:!0,transparent:!0,opacity:t}),this.hintMaterialDisposable=!0)}experimentalUpdateOptions(t){void 0!==t.hintFacelets&&this.showHintFacelets("none"!==t.hintFacelets),void 0!==t.showFoundation&&this.showFoundation(t.showFoundation),void 0!==t.hintStickerOpacity&&this.setHintStickerOpacity(t.hintStickerOpacity),(0,r.OV)(this,tt,!0),this.lastPos&&this.onPositionChange(this.lastPos),"undefined"!==typeof t.faceletScale&&t.faceletScale!==this.faceletScale&&console.warn("Dynamic facelet scale is not yet supported for PG3D. For now, re-create the TwistyPlayer to change the facelet scale."),this.updateMaterialArrays(),this.scheduleRenderCallback()}adduvs(){const t=this.filler;if(t.uvs)return;this.filler.uvs=new Float32Array(12*t.sz);for(const i in this.stickers){const t=this.stickers[i],e=t.length;for(let i=0;i<e;i++){const e=t[i];for(const t of e)t.addUVs(this.filler)}}t.uvs.copyWithin(6*t.sz,0,6*t.sz);const e=t.uvs.subarray(0,6*t.sz);this.fixedGeo.setAttribute("uv",new s.TH(e,2,!0))}experimentalUpdateTexture(t,e,i){e||(t=!1),t&&!this.filler.uvs&&this.adduvs(),this.textured=t,this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterialDisposable=!1),t?(this.stickerMaterial=new s.V9({map:e,side:s.hB,transparent:!1}),this.stickerMaterialDisposable=!0):this.stickerMaterial=$,this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),t?(this.hintMaterial=new s.V9({map:i,side:s.hB,transparent:!0}),this.hintMaterialDisposable=!0):this.hintMaterial=$,t&&this.showHintFacelets(null!==i),this.updateMaterialArrays(),(0,r.OV)(this,tt,!0),this.lastPos&&this.onPositionChange(this.lastPos),this.scheduleRenderCallback()}},tt=new WeakMap,et=new WeakSet,it=function(t){try{return this.kpuzzle.moveToTransformation(t),!0}catch(e){return!1}},st),lt=class{constructor(){(0,r.Mu)(this,"renderTargets",new Set),(0,r.Mu)(this,"twisty3Ds",new Set),(0,r.Mu)(this,"threeJSScene",(async()=>new(await s.u_).Scene)())}addRenderTarget(t){this.renderTargets.add(t)}scheduleRender(){for(const t of this.renderTargets)t.scheduleRender()}async addTwisty3DPuzzle(t){this.twisty3Ds.add(t),(await this.threeJSScene).add(t)}async removeTwisty3DPuzzle(t){this.twisty3Ds.delete(t),(await this.threeJSScene).remove(t)}async clearPuzzles(){for(const t of this.twisty3Ds)(await this.threeJSScene).remove(t);this.twisty3Ds.clear()}};async function ut(t,e){return new Q(await s.P$.kpuzzle(),t,e)}async function pt(t,e,i,s,n){return new ct(t,await e.kpuzzle(),(await e.pg()).get3d({darkIgnoredOrbits:n}),!0,"floating"===i,void 0,s)}}}]);
//# sourceMappingURL=909.4d15ee4d.chunk.js.map