{"version":3,"file":"static/js/938.78f59987.chunk.js","mappings":"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CA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,QAGJ,GAAI,CACF2H,EAAG,CACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAEF1P,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MAEF+H,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QAiCN,SAASsR,GAAYzX,EAAG4G,GACtB,IAAK,IAAIjK,EAAI,EAAGA,EAAIqD,EAAEnD,OAAQF,IAC5B,GAAIqD,EAAErD,GAAG,GAAG8U,KAAK7K,GAAK2Q,GACpB,OAAO5a,EAGX,MAAM,IAAIa,MAAM,oBAClB,CACA,SAASka,KACP,OAAOtI,CACT,CACA,SAASuI,GAA2BC,GAClC,OAAOxI,EAAUwI,EACnB,CACA,IAAIC,GAAqB,CAAC,IAAK,IAAK,IAAK,IAAK,KAC1CC,GAAmB,CAAC,IAAK,IAAK,KAClC,SAASpS,GAAuBvI,GAC9B,MAAM6C,EAAI7C,EAAE6H,MAAM,KAAK+S,OAAOC,SAC9B,GAAIhY,EAAEnD,OAAS,IAAM,EACnB,OAAO,KAET,MAAMob,EAAQjY,EAAE,GAChB,GAAc,MAAViY,GAA2B,MAAVA,GAA2B,MAAVA,GAA2B,MAAVA,GAA2B,MAAVA,EACtE,OAAO,KAET,MAAMC,EAAO,GACb,IAAK,IAAIvb,EAAI,EAAGA,EAAIqD,EAAEnD,OAAQF,GAAK,EAAG,CACpC,GAAa,MAATqD,EAAErD,IAAuB,MAATqD,EAAErD,IAAuB,MAATqD,EAAErD,GACpC,OAAO,KAETub,EAAKza,KAAK,CACR0a,QAASnY,EAAErD,GACXyb,SAAUC,WAAWrY,EAAErD,EAAI,KAE/B,CACA,MAAO,CAAEsb,QAAOC,OAClB,CACA,SAASI,GAAwBC,G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","sources":["../node_modules/scramble-display/dist/esm/puzzle-geometry-JCNGBESZ.js"],"sourcesContent":["import {\n  Move,\n  QuantumMove\n} from \"./chunk-NCGRY2AA.js\";\nimport {\n  __publicField\n} from \"./chunk-YPFRV6UN.js\";\n\n// node_modules/cubing/dist/lib/cubing/puzzle-geometry/index.js\nfunction defaultPlatonicColorSchemes() {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: {\n      F: \"#44ee00\",\n      D: \"#f4f400\",\n      L: \"#ff0000\",\n      R: \"#2266ff\"\n      /* Blue */\n    },\n    6: {\n      U: \"#ffffff\",\n      F: \"#44ee00\",\n      R: \"#ff0000\",\n      D: \"#f4f400\",\n      B: \"#2266ff\",\n      L: \"#ff8000\"\n      /* Orange */\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#44ee00\",\n      R: \"#ff0000\",\n      D: \"#f4f400\",\n      BB: \"#2266ff\",\n      L: \"#8800dd\",\n      BL: \"#ff8000\",\n      BR: \"#888888\"\n      /* MediumGray */\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#008800\",\n      R: \"#ff0000\",\n      C: \"#e8d0a0\",\n      A: \"#3399ff\",\n      L: \"#8800dd\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#f4f400\",\n      I: \"#ff8000\",\n      D: \"#888888\"\n      /* MediumGray */\n    },\n    20: {\n      R: \"#f4f400\",\n      C: \"#d41f69\",\n      F: \"#008800\",\n      E: \"#5c5c5c\",\n      L: \"#8800dd\",\n      U: \"#ffffff\",\n      A: \"#007a89\",\n      G: \"#ff0000\",\n      I: \"#7d3b11\",\n      S: \"#b9a1ff\",\n      H: \"#3399ff\",\n      J: \"#5ec4b6\",\n      B: \"#44ee00\",\n      K: \"#e8d0a0\",\n      D: \"#aaaaaa\",\n      M: \"#ff66cc\",\n      O: \"#292929\",\n      P: \"#ff8000\",\n      N: \"#980000\",\n      Q: \"#0000ff\"\n      /* BoldBlue */\n    }\n  };\n}\nvar FaceNameSwizzler = class {\n  constructor(facenames, gripnames_arg) {\n    __publicField(this, \"prefixFree\", true);\n    __publicField(this, \"gripnames\", []);\n    this.facenames = facenames;\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n  setGripNames(names) {\n    this.gripnames = names;\n  }\n  // split a string into face names and return a list of\n  // indices.\n  splitByFaceNames(s) {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (s.substr(at).startsWith(this.facenames[i]) && (currentMatch < 0 || this.facenames[i].length > this.facenames[currentMatch].length)) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(`Could not split ${s} into face names.`);\n      }\n    }\n    return r;\n  }\n  // cons a grip from an array of numbers.\n  joinByFaceIndices(list) {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  spinmatch(userinput, longname) {\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /* same as above, but permit both to have v's on the end. */\n  spinmatchv(userinput, longname) {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1)\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n  unswizzle(s) {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n};\nvar NullMapper = class {\n  notationToInternal(move) {\n    return move;\n  }\n  notationToExternal(move) {\n    return move;\n  }\n};\nvar FTONotationMapper = class {\n  constructor(child, sw) {\n    this.child = child;\n    this.sw = sw;\n  }\n  notationToInternal(move) {\n    if (move.family === \"T\" && move.innerLayer === void 0 && move.outerLayer === void 0) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n  // we never rewrite click moves to these moves.\n  notationToExternal(move) {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n};\nvar FaceRenamingMapper = class {\n  constructor(internalNames, externalNames) {\n    this.internalNames = internalNames;\n    this.externalNames = externalNames;\n  }\n  // TODO:  consider putting a cache in front of this\n  convertString(grip, a, b) {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n  convert(move, a, b) {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount\n      );\n    }\n  }\n  notationToInternal(move) {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n  notationToExternal(move) {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n};\nvar MegaminxScramblingNotationMapper = class {\n  constructor(child) {\n    this.child = child;\n  }\n  notationToInternal(move) {\n    if (move.innerLayer === void 0 && move.outerLayer === void 0) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"ERv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n  // we never rewrite click moves to these moves.\n  notationToExternal(move) {\n    if (move.family === \"ERv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        move.amount * 2\n      );\n    }\n    if (move.family === \"ILv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        -move.amount * 2\n      );\n    }\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n};\nvar NxNxNCubeMapper = class {\n  constructor(slices) {\n    this.slices = slices;\n  }\n  notationToInternal(move) {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount\n          );\n        }\n      }\n    }\n    return move;\n  }\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  notationToExternal(move) {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n};\nvar pyraminxFamilyMap = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\"\n};\nvar tetraminxFamilyMap = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\"\n};\nvar pyraminxFamilyMapWCA = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\"\n};\nvar pyraminxExternalQuantumY = new QuantumMove(\"y\");\nvar pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\nvar PyraminxNotationMapper = class {\n  constructor(child) {\n    __publicField(this, \"wcaHack\", false);\n    __publicField(this, \"map\", pyraminxFamilyMap);\n    this.child = child;\n  }\n  notationToInternal(move) {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n  // we never rewrite click moves to these moves.\n  notationToExternal(move) {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n};\nvar TetraminxNotationMapper = class extends PyraminxNotationMapper {\n  constructor(child) {\n    super(child);\n    __publicField(this, \"wcaHack\", true);\n    this.map = tetraminxFamilyMap;\n  }\n};\nvar skewbFamilyMap = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\"\n};\nvar skewbExternalQuantumX = new QuantumMove(\"x\");\nvar skewbInternalQuantumX = new QuantumMove(\"Rv\");\nvar skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nvar skewbExternalQuantumY = new QuantumMove(\"y\");\nvar skewbInternalQuantumY = new QuantumMove(\"Uv\");\nvar skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nvar skewbExternalQuantumZ = new QuantumMove(\"z\");\nvar skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nvar skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\nvar SkewbNotationMapper = class {\n  constructor(child) {\n    this.child = child;\n  }\n  notationToInternal(move) {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n  }\n  // we never rewrite click moves to these moves.\n  notationToExternal(move) {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n  }\n};\nfunction remapKPuzzleDefinition(internalDefinition, notationMapper) {\n  const externalDefinition = {\n    ...internalDefinition,\n    moves: {}\n  };\n  for (const [internalMoveName, transformationData] of Object.entries(\n    internalDefinition.moves\n  )) {\n    let prefix = internalMoveName;\n    let suffix = \"\";\n    if ([\"v\", \"w\"].includes(internalMoveName.at(-1))) {\n      prefix = internalMoveName.slice(0, -1);\n      suffix = internalMoveName.slice(-1);\n    }\n    const externalPrefix = notationMapper.notationToExternal(\n      Move.fromString(prefix)\n    );\n    if (!externalPrefix) {\n      continue;\n    }\n    const externalMoveName = externalPrefix + suffix;\n    if (!externalMoveName) {\n      throw new Error(\n        `Missing external move name for: ${internalMoveName.toString()}`\n      );\n    }\n    externalDefinition.moves[externalMoveName.toString()] = transformationData;\n  }\n  return externalDefinition;\n}\nfunction parseOptions(argv) {\n  let argp = 0;\n  const options = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]);\n      argp++;\n    } else {\n      throw new Error(`Bad option: ${option}`);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\nvar PuzzleGeometryFullOptions = class {\n  // scramble?\n  constructor(options = {}) {\n    __publicField(this, \"verbosity\", 0);\n    // verbosity (console.log)\n    __publicField(this, \"allMoves\", false);\n    // generate all slice moves in ksolve\n    __publicField(this, \"outerBlockMoves\");\n    // generate outer block moves\n    __publicField(this, \"vertexMoves\", false);\n    // generate vertex moves\n    __publicField(this, \"addRotations\", false);\n    // add symmetry information to ksolve output\n    __publicField(this, \"moveList\", null);\n    // move list to generate\n    __publicField(this, \"fixedOrientation\", false);\n    // eliminate any orientations\n    __publicField(this, \"fixedPieceType\", null);\n    // fix a piece?\n    __publicField(this, \"orientCenters\", false);\n    // orient centers?\n    // TODO: Group these into a single object?\n    __publicField(this, \"includeCornerOrbits\", true);\n    // include corner orbits\n    __publicField(this, \"includeCenterOrbits\", true);\n    // include center orbits\n    __publicField(this, \"includeEdgeOrbits\", true);\n    // include edge orbits\n    // Overrides the previous options.\n    __publicField(this, \"excludeOrbits\", []);\n    // exclude these orbits\n    __publicField(this, \"optimizeOrbits\", false);\n    // optimize PermOri\n    __publicField(this, \"grayCorners\", false);\n    // make corner sets gray\n    __publicField(this, \"grayCenters\", false);\n    // make center sets gray\n    __publicField(this, \"grayEdges\", false);\n    // make edge sets gray\n    __publicField(this, \"puzzleOrientation\", null);\n    // single puzzle orientation from options\n    __publicField(this, \"puzzleOrientations\", null);\n    // puzzle orientation override object from options // TODO: is this needed?\n    __publicField(this, \"scrambleAmount\", 0);\n    Object.assign(this, options);\n  }\n};\nvar zeroCache = [];\nvar iotaCache = [];\nfunction zeros(n) {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\nfunction iota(n) {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\nfunction identity(n) {\n  return new Perm(iota(n));\n}\nfunction factorial(a) {\n  let r = BigInt(1);\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\nfunction gcd(a, b) {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\nfunction lcm(a, b) {\n  return a / gcd(a, b) * b;\n}\nvar Perm = class _Perm {\n  // The permutation itself\n  constructor(a) {\n    __publicField(this, \"n\");\n    // length\n    __publicField(this, \"p\");\n    this.n = a.length;\n    this.p = a;\n  }\n  toString() {\n    return `Perm[${this.p.join(\" \")}]`;\n  }\n  mul(p2) {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new _Perm(c);\n  }\n  rmul(p2) {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new _Perm(c);\n  }\n  inv() {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new _Perm(c);\n  }\n  compareTo(p2) {\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n  toGap() {\n    const cyc = new Array();\n    const seen = new Array(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array();\n      for (let j = this.p[i]; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`(${incyc.reverse().join(\",\")})`);\n    }\n    return cyc.join(\"\");\n  }\n  toMathematica() {\n    const cyc = new Array();\n    const seen = new Array(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array();\n      for (let j = this.p[i]; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`{${incyc.reverse().join(\",\")}}`);\n    }\n    return `Cycles[{${cyc.join(\",\")}}]`;\n  }\n  order() {\n    let r = 1;\n    const seen = new Array(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n};\nvar PGOrbitDef = class {\n  constructor(size, mod) {\n    this.size = size;\n    this.mod = mod;\n  }\n  reassemblySize() {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n};\nvar lastGlobalDefinitionCounter = 0;\nfunction externalName(mapper, moveString) {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\nvar PGOrbitsDef = class _PGOrbitsDef {\n  constructor(orbitnames, orbitdefs, solved, movenames, moveops, isRotation, forcenames) {\n    this.orbitnames = orbitnames;\n    this.orbitdefs = orbitdefs;\n    this.solved = solved;\n    this.movenames = movenames;\n    this.moveops = moveops;\n    this.isRotation = isRotation;\n    this.forcenames = forcenames;\n  }\n  toKTransformationData(t) {\n    const ktransformationData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      ktransformationData[this.orbitnames[i]] = t.orbits[i].toKTransformationOrbitData();\n    }\n    return ktransformationData;\n  }\n  toKPatternData(t) {\n    const kpatternData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      kpatternData[this.orbitnames[i]] = t.orbits[i].toKPatternOrbitData();\n    }\n    return kpatternData;\n  }\n  // TODO: remove this\n  static transformToKTransformationData(orbitnames, t) {\n    const mp = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKTransformationOrbitData();\n    }\n    return mp;\n  }\n  describeSet(s, r, mapper) {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] !== j || pd.ori[j] !== 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(`# ${j + 1} ${m[j].join(\" \")}`);\n    }\n  }\n  toKsolve(name, mapper = new NullMapper()) {\n    const result = [];\n    result.push(`Name ${name}`);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`\n      );\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name2 = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name2 = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name2[name2.length - 1] === \"'\") {\n        doinv = true;\n        name2 = name2.substring(0, name2.length - 1);\n      }\n      result.push(`Move ${name2}`);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j].inv().appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    return result;\n  }\n  // TODO: return type.\n  toKPuzzleDefinition(includemoves) {\n    const orbits = [];\n    const defaultPatternData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits.push({\n        orbitName: this.orbitnames[i],\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod\n      });\n      const defaultPatternFrom = this.solved.orbits[i].toKTransformationOrbitData();\n      defaultPatternData[this.orbitnames[i]] = {\n        pieces: defaultPatternFrom.permutation,\n        orientation: defaultPatternFrom.orientationDelta\n      };\n    }\n    const moves = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.toKTransformationData(this.moveops[i]);\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      defaultPattern: defaultPatternData,\n      moves\n    };\n  }\n  optimize() {\n    const neworbitnames = [];\n    const neworbitdefs = [];\n    const newsolved = [];\n    const newmoveops = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (this.moveops[j].orbits[i].perm[k] !== k || this.moveops[j].orbits[i].ori[k] !== 0) {\n            if (!this.isRotation[j]) {\n              changed[k] = true;\n            }\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k || this.moveops[j].orbits[i].ori[k] !== 0) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om + (o + this.moveops[j].orbits[i].ori[k]) % om\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no = [];\n        const on = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri()\n            );\n          }\n        }\n      }\n    }\n    return new _PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n      this.isRotation,\n      this.forcenames\n    );\n  }\n  // replace the solved state with a new scrambled state.\n  scramble(n) {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  getScrambleTransformation(n) {\n    if (n < 100) {\n      n = 100;\n    }\n    const pool = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n  reassemblySize() {\n    let n = BigInt(1);\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n};\nvar _a;\nvar PGOrbit = (_a = class {\n  constructor(perm, ori, orimod) {\n    this.perm = perm;\n    this.ori = ori;\n    this.orimod = orimod;\n  }\n  static e(n, mod) {\n    return new _a(iota(n), zeros(n), mod);\n  }\n  mul(b) {\n    const n = this.perm.length;\n    const newPerm = new Array(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new _a(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new _a(newPerm, newOri, this.orimod);\n    }\n  }\n  inv() {\n    const n = this.perm.length;\n    const newPerm = new Array(n);\n    const newOri = new Array(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new _a(newPerm, newOri, this.orimod);\n  }\n  equal(b) {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // in-place mutator\n  killOri() {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n  toPerm() {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + (this.ori[i] + j) % o;\n      }\n    }\n    return new Perm(newPerm);\n  }\n  // returns tuple of sets of identical pieces in this orbit\n  identicalPieces() {\n    const done = [];\n    const n = this.perm.length;\n    const r = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === void 0) {\n        const s = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n  order() {\n    return this.toPerm().order();\n  }\n  isIdentity() {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  zeroOris() {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  remap(no, on, nv) {\n    const newPerm = new Array(nv);\n    const newOri = new Array(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new _a(newPerm, newOri, this.orimod);\n  }\n  remapVS(no, nv) {\n    const newPerm = new Array(nv);\n    const newOri = new Array(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === void 0) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new _a(newPerm, newOri, this.orimod);\n  }\n  appendDefinition(result, name, useVS, concise = true) {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n  toKTransformationOrbitData() {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!_a.ktransformationCache[n]) {\n        _a.ktransformationCache[n] = {\n          permutation: iota(n),\n          orientationDelta: zeros(n)\n        };\n      }\n      return _a.ktransformationCache[n];\n    } else {\n      return { permutation: this.perm, orientationDelta: this.ori };\n    }\n  }\n  toKPatternOrbitData() {\n    const n = this.perm.length;\n    return {\n      pieces: this.perm,\n      orientation: this.ori,\n      orientationMod: zeros(n)\n    };\n  }\n}, __publicField(_a, \"ktransformationCache\", []), _a);\nvar PGTransformBase = class {\n  constructor(orbits) {\n    this.orbits = orbits;\n  }\n  internalMul(b) {\n    const newOrbits = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n  internalInv() {\n    const newOrbits = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n  equal(b) {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  killOri() {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n  toPerm() {\n    const perms = new Array();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n  identicalPieces() {\n    const r = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n  order() {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n};\nvar PGTransform = class _PGTransform extends PGTransformBase {\n  mul(b) {\n    return new _PGTransform(this.internalMul(b));\n  }\n  mulScalar(n) {\n    if (n === 0) {\n      return this.e();\n    }\n    let t = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n  inv() {\n    return new _PGTransform(this.internalInv());\n  }\n  e() {\n    return new _PGTransform(\n      this.orbits.map((_) => PGOrbit.e(_.perm.length, _.orimod))\n    );\n  }\n};\nvar VisibleState = class _VisibleState extends PGTransformBase {\n  mul(b) {\n    return new _VisibleState(this.internalMul(b));\n  }\n};\nvar DisjointUnion = class {\n  constructor(n) {\n    __publicField(this, \"heads\");\n    this.n = n;\n    this.heads = new Array(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n  find(v) {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n  union(a, b) {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n};\nfunction showcanon(g, disp) {\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti;\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if ((st >> mv & 1) === 0 && (st & commutes[mv] & (1 << mv) - 1) === 0) {\n          const nst = st & commutes[mv] | 1 << mv;\n          if (nextlev[nst] === void 0) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\nvar PGPuzzles = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\": \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\": \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\": \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\": \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\": \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\": \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  skewb: \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  helicopter: \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  dino: \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  pyramorphix: \"t e 0\",\n  mastermorphix: \"t e 0.346184634065199\",\n  pyraminx: \"t v 0.333333333333333 v 1.66666666666667\",\n  tetraminx: \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"royal pyraminx\": \"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333\",\n  \"royal tetraminx\": \"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667\",\n  \"emperor pyraminx\": \"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143\",\n  \"emperor tetraminx\": \"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  megaminx: \"d f 0.7\",\n  gigaminx: \"d f 0.64 f 0.82\",\n  teraminx: \"d f 0.64 f 0.76 f 0.88\",\n  petaminx: \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  examinx: \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  zetaminx: \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  yottaminx: \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  pentultimate: \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  starminx: \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  chopasaurus: \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  FTO: \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  octastar: \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  icosamate: \"i v 0\",\n  \"Regular Astrominx\": \"i v 0.18759247376021\",\n  \"Regular Astrominx + Big Chop\": \"i v 0.18759247376021 e 0\",\n  Redicosahedron: \"i v 0.794654472291766\",\n  \"Redicosahedron with centers\": \"i v 0.84\",\n  Icosaminx: \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\"\n};\nvar eps = 1e-9;\nfunction centermassface(face) {\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1 / face.length);\n}\nfunction solvethreeplanes(p1, p2, p3, planes) {\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (planes[i].a > 0 && dt > planes[i].a || planes[i].a < 0 && dt < planes[i].a) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\nvar Quat = class _Quat {\n  constructor(a, b, c, d) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n  }\n  mul(q) {\n    return new _Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a\n    );\n  }\n  toString() {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n  dist(q) {\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  len() {\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n  cross(q) {\n    return new _Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b\n    );\n  }\n  dot(q) {\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n  normalize() {\n    const d = Math.sqrt(this.dot(this));\n    return new _Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  makenormal() {\n    return new _Quat(0, this.b, this.c, this.d).normalize();\n  }\n  normalizeplane() {\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new _Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  smul(m) {\n    return new _Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n  sum(q) {\n    return new _Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n  sub(q) {\n    return new _Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  angle() {\n    return 2 * Math.acos(this.a);\n  }\n  invrot() {\n    return new _Quat(this.a, -this.b, -this.c, -this.d);\n  }\n  det3x3(a00, a01, a02, a10, a11, a12, a20, a21, a22) {\n    return a00 * (a11 * a22 - a12 * a21) + a01 * (a12 * a20 - a10 * a22) + a02 * (a10 * a21 - a11 * a20);\n  }\n  rotateplane(q) {\n    const t = q.mul(new _Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  orthogonal() {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new _Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new _Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new _Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  pointrotation(b) {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new _Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  unproject(b) {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n  rotatepoint(q) {\n    return q.mul(this).mul(q.invrot());\n  }\n  rotateface(face) {\n    return face.map((_) => _.rotatepoint(this));\n  }\n  intersect3(p2, p3) {\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d\n    );\n    if (Math.abs(det) < eps) {\n      return false;\n    }\n    return new _Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det\n    );\n  }\n  side(x) {\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  cutface(face) {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << this.side(face[i].dot(this) - d) + 1;\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      const inout = face.map((_) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r2 = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r2).sum(face[kk].smul(r2));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n  cutfaces(faces) {\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n  faceside(face) {\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n  sameplane(p) {\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n  makecut(r) {\n    return new _Quat(r, this.b, this.c, this.d);\n  }\n};\nvar eps2 = 1e-9;\nfunction cube() {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\nfunction tetrahedron() {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\nfunction dodecahedron() {\n  const d36 = 2 * Math.PI / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5)\n  ];\n}\nfunction icosahedron() {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = 2 * Math.PI / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)\n  ];\n}\nfunction octahedron() {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\nfunction closure(g) {\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps2 || negns.dist(q[k]) < eps2) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\nfunction uniqueplanes(p, g) {\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps2) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\nfunction getface(planes) {\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps2) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (; ; ) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\nvar FactoredNumber = class {\n  constructor() {\n    __publicField(this, \"mult\");\n    this.mult = [];\n  }\n  multiply(n) {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (void 0 !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (void 0 !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n  toString() {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (void 0 !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n};\nfunction schreierSims(g, disp) {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs = [];\n  let sgsi = [];\n  let sgslen = [];\n  let Tk = [];\n  let Tklen = [];\n  function resolve(p) {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k, p, len) {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k, p, len) {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs() {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = BigInt(1);\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = BigInt(1);\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\nfunction tstart(s) {\n  return s;\n}\nfunction tend(_) {\n}\nvar Face = class _Face {\n  constructor(q) {\n    __publicField(this, \"coords\");\n    __publicField(this, \"length\");\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n  get(off) {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2]\n    );\n  }\n  centermass() {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n  rotate(q) {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new _Face(a);\n  }\n  rotateforward() {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new _Face(a);\n  }\n};\nvar FaceTree = class _FaceTree {\n  constructor(face, left, right) {\n    this.face = face;\n    this.left = left;\n    this.right = right;\n  }\n  split(q) {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === void 0) {\n        this.left = new _FaceTree(t[0]);\n        this.right = new _FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n  collect(arr, leftfirst) {\n    if (this.left === void 0) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n};\nfunction expandfaces(rots, faces) {\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\nvar eps3 = 1e-9;\nvar copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nvar permissivieMoveParsing = false;\nfunction defaultnets() {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"]\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"]\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"]\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"]\n    ]\n  };\n}\nvar orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"]\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"]\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\"\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"]\n  },\n  12: {\n    v: [\n      \"URF\",\n      \"UFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DEBF\",\n      \"DBFI\",\n      \"DIA\",\n      \"DAC\",\n      \"DCE\",\n      \"LAI\",\n      \"ALF\",\n      \"FCA\",\n      \"CFR\",\n      \"REC\",\n      \"ERBR\",\n      \"BRBFE\",\n      \"BFBRBL\",\n      \"BLIBF\",\n      \"IBLL\"\n    ],\n    e: [\n      \"UF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"ER\",\n      \"EBR\",\n      \"EBF\",\n      \"ED\",\n      \"EC\",\n      \"IBF\",\n      \"IBL\",\n      \"IL\",\n      \"IA\",\n      \"ID\",\n      \"AC\",\n      \"CF\",\n      \"FA\",\n      \"BFBR\",\n      \"BRBL\",\n      \"BLBF\",\n      \"CD\",\n      \"AD\",\n      \"AL\",\n      \"FL\",\n      \"FR\",\n      \"CR\",\n      \"BFD\",\n      \"BRR\",\n      \"BLL\"\n    ],\n    c: [\n      \"UF\",\n      \"FU\",\n      \"DBF\",\n      \"BFD\",\n      \"AD\",\n      \"CD\",\n      \"BRU\",\n      \"BLU\",\n      \"LA\",\n      \"RA\",\n      \"EBR\",\n      \"IBL\"\n    ]\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\"\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\"\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\"\n    ]\n  }\n};\nfunction defaultOrientations() {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ]\n    // F towards viewer\n  };\n}\nfunction findelement(a, p) {\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps3) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\nfunction getPG3DNamedPuzzles() {\n  return PGPuzzles;\n}\nfunction getPuzzleDescriptionString(puzzleName) {\n  return PGPuzzles[puzzleName];\n}\nvar PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"];\nvar PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"];\nfunction parsePuzzleDescription(s) {\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (shape !== \"o\" && shape !== \"c\" && shape !== \"i\" && shape !== \"d\" && shape !== \"t\") {\n    return null;\n  }\n  const cuts = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i],\n      distance: parseFloat(a[i + 1])\n    });\n  }\n  return { shape, cuts };\n}\nfunction getPuzzleGeometryByDesc(desc, options = {}) {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true }, options)\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\nfunction getPuzzleGeometryByName(puzzleName, options) {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\nfunction getmovename(geo, bits, slices) {\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = `${movenameFamily}v`;\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw new Error(\n      `We only support slice and outer block moves right now. ${bits}`\n    );\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\nfunction splitByFaceNames(s, facenames) {\n  const r = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (s.substr(at).startsWith(facename[1]) && facename[1].length > currentMatch.length) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(`Could not split ${s} into face names.`);\n    }\n  }\n  return r;\n}\nfunction toCoords(q, maxdist) {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\nfunction toFaceCoords(q, maxdist) {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\nvar PuzzleGeometry = class {\n  constructor(puzzleDescription, options) {\n    __publicField(this, \"rotations\");\n    // all members of the rotation group\n    __publicField(this, \"baseplanerot\");\n    // unique rotations of the baseplane\n    __publicField(this, \"baseplanes\");\n    // planes, corresponding to faces\n    __publicField(this, \"facenames\");\n    // face names\n    __publicField(this, \"faceplanes\");\n    // face planes\n    __publicField(this, \"edgenames\");\n    // edge names\n    __publicField(this, \"vertexnames\");\n    // vertexnames\n    __publicField(this, \"geonormals\");\n    // all geometric directions, with names and types\n    __publicField(this, \"moveplanes\");\n    // the planes that split moves\n    __publicField(this, \"moveplanes2\");\n    // the planes that split moves, filtered\n    __publicField(this, \"moveplanesets\");\n    // the move planes, in parallel sets\n    __publicField(this, \"moveplanenormals\");\n    // one move plane\n    __publicField(this, \"movesetorders\");\n    // the order of rotations for each move set\n    __publicField(this, \"movesetgeos\");\n    // geometric feature information for move sets\n    __publicField(this, \"basefaces\");\n    // polytope faces before cuts\n    __publicField(this, \"faces\");\n    // all the stickers\n    __publicField(this, \"facecentermass\");\n    // center of mass of all faces\n    __publicField(this, \"baseFaceCount\");\n    // number of base faces\n    __publicField(this, \"stickersperface\");\n    // number of stickers per face\n    __publicField(this, \"shortedge\");\n    // number of stickers per face\n    __publicField(this, \"markedface\");\n    // given a bitmap of faces, identify the marked one\n    __publicField(this, \"cubies\");\n    // the cubies\n    __publicField(this, \"vertexdistance\");\n    // vertex distance\n    __publicField(this, \"edgedistance\");\n    // edge distance\n    __publicField(this, \"facetocubie\");\n    // map a face to a cubie index\n    __publicField(this, \"facetoord\");\n    // map a face to a cubie ord\n    __publicField(this, \"moverotations\");\n    // move rotations\n    __publicField(this, \"facelisthash\");\n    // face list by key\n    __publicField(this, \"cubiesetnames\");\n    // cubie set names\n    __publicField(this, \"cubieords\");\n    // the size of each orbit\n    __publicField(this, \"cubiesetnums\");\n    __publicField(this, \"cubieordnums\");\n    __publicField(this, \"orbitoris\");\n    // the orientation size of each orbit\n    __publicField(this, \"cubievaluemap\");\n    // the map for identical cubies\n    __publicField(this, \"cubiesetcubies\");\n    // cubies in each cubie set\n    __publicField(this, \"cmovesbyslice\", []);\n    // cmoves as perms by slice\n    __publicField(this, \"parsedmovelist\");\n    // parsed move list\n    __publicField(this, \"duplicatedFaces\", []);\n    // which faces are duplicated\n    __publicField(this, \"duplicatedCubies\", []);\n    // which cubies are duplicated\n    __publicField(this, \"fixedCubie\", -1);\n    // fixed cubie, if any\n    __publicField(this, \"net\", []);\n    __publicField(this, \"colors\", []);\n    __publicField(this, \"swizzler\");\n    __publicField(this, \"notationMapper\", new NullMapper());\n    __publicField(this, \"addNotationMapper\", \"\");\n    __publicField(this, \"setReidOrder\", false);\n    __publicField(this, \"options\");\n    this.puzzleDescription = puzzleDescription;\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n  create(puzzleDescription) {\n    const { shape, cuts } = puzzleDescription;\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": {\n        g = cube();\n        break;\n      }\n      case \"o\": {\n        g = octahedron();\n        break;\n      }\n      case \"i\": {\n        g = icosahedron();\n        break;\n      }\n      case \"t\": {\n        g = tetrahedron();\n        break;\n      }\n      case \"d\": {\n        g = dodecahedron();\n        break;\n      }\n      default:\n        throw new Error(`Bad shape argument: ${shape}`);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(`# Rotations: ${this.rotations.length}`);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultPlatonicColorSchemes()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(`# Base planes: ${baseplanes.length}`);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(`# Face vertices: ${baseface.length}`);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(`# Boundary is ${boundary}`);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false;\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\": {\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        }\n        case \"v\": {\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        }\n        case \"e\": {\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        }\n        default:\n          throw new Error(`Bad cut argument: ${cut.cutType}`);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    const facenames = [];\n    const faceplanes = [];\n    const vertexnames = [];\n    const edgenames = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a, p, name) {\n      for (const el of a) {\n        if (el[0].dist(p) < eps3) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex = {};\n    const faceindextoname = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === void 0) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== void 0 && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== void 0 && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = 1 << fn[0] | 1 << this.baseFaceCount;\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(`Bad length in edge names ${edgenames[i]}`);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = 1 << f1 | 1 << f2;\n      if (markedface[bits] === f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw new Error(\n          \"Internal error; couldn't find face name when fixing corners\"\n        );\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedface = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(`# Face names: ${facenames.map((_) => _[1]).join(\" \")}`);\n      console.log(`# Edge names: ${edgenames.map((_) => _[1]).join(\" \")}`);\n      console.log(`# Vertex names: ${vertexnames.map((_) => _[1]).join(\" \")}`);\n    }\n    const geonormals = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        `# Distances: face ${1} edge ${this.edgedistance} vertex ${this.vertexdistance}`\n      );\n    }\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(`# Faces is now ${faces.length}`);\n    }\n    this.stickersperface = faces.length;\n    const simplerot = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps3) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array(faces.length);\n    const sortme = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm2 = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps3) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm2.dist(sortme[kk][1]) < eps3) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(`# Short edge is ${this.shortedge}`);\n    }\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"])\n      );\n      if (!(sawedge || sawvertex)) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\"\n        ])\n      );\n    }\n  }\n  keyface(face) {\n    return this.keyface2(face.centermass());\n  }\n  keyface2(cm) {\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + t % 47);\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) + sfcc(33 + 47 + Math.floor((t - 47) / 47) % 47) + sfcc(33 + t % 47);\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  keyface3(face) {\n    const cm = face.centermass();\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n  findface(cm) {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key);\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)[i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps3) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n  project2d(facen, edgen, targvec) {\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0\n    );\n    return [x1, y1, off];\n  }\n  allstickers() {\n    const t1 = tstart(\"allstickers\");\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(`# Total stickers is now ${this.faces.length}`);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    const moveplanesets = [];\n    const moveplanenormals = [];\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps3) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(`# Move plane sets: ${sizes}`);\n    }\n    const moverotations = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps3) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps3) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps3) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps3) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"SkewbMapper\" && moveplanesets[0].length === 1) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (moveplanesets[0].length === 2 && moveplanesets[0][0].a === 0.333333333333333 && moveplanesets[0][1].a === 1.66666666666667) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    const facelisthash = /* @__PURE__ */ new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s);\n        arr.push(i);\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = `${s} ${suff}`;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubies: ${facelisthash.size}`);\n    }\n    const cubies = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        continue;\n      }\n      if (facelist.length > 1) {\n        const cm = facelist.map((_) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1e3) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersperface);\n        }\n        const markedface = this.markedface[bits];\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersperface) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw new Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    const getcolorkey = (cubienum) => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === void 0 || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === void 0) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq = this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (this.setReidOrder && 4 <= this.stickersperface && this.stickersperface <= 9) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\"\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"]\n      ];\n      const reidmap = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << cubie[j].charCodeAt(k) - 65;\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |= 1 << this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65;\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (this.options.fixedPieceType === \"v\" && cubies[i].length > 2 || this.options.fixedPieceType === \"e\" && cubies[i].length === 2 || this.options.fixedPieceType === \"f\" && cubies[i].length === 1) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          `Could not find a cubie of type ${this.options.fixedPieceType} to fix.`\n        );\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubie orbit sizes ${cubieords}`);\n    }\n    tend(t1);\n  }\n  unswizzle(mv) {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  stringToBlockMove(mv) {\n    const re = /^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/;\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(`Bad move passed ${mv}`);\n    }\n    const grip = p[4];\n    let loslice = void 0;\n    let hislice = void 0;\n    if (p[2] !== void 0) {\n      if (p[3] === void 0) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== void 0) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== void 0) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = `-${amountstr.substring(1)}`;\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n  parseMove(move) {\n    const bm = this.notationMapper.notationToInternal(move);\n    if (bm === null) {\n      throw new Error(`Bad move ${move.family}`);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== void 0 || move.outerLayer !== void 0) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === void 0) {\n      throw new Error(`Bad grip in move ${move.family}`);\n    }\n    if (move.outerLayer !== void 0) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== void 0) {\n      if (move.outerLayer === void 0) {\n        hislice = move.innerLayer;\n        if (grip <= \"Z\") {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (loslice < 0 || loslice > this.moveplanesets[msi].length || hislice < 0 || hislice > this.moveplanesets[msi].length) {\n      throw new Error(\n        `Bad slice spec ${loslice} ${hislice} vs ${this.moveplanesets[msi].length}`\n      );\n    }\n    if (!permissivieMoveParsing && loslice === 0 && hislice === this.moveplanesets[msi].length && !fullrotation) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\"\n      );\n    }\n    return [void 0, msi, loslice, hislice, firstgrip, move.amount];\n  }\n  parsemove(mv) {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n  genperms() {\n    const t1 = tstart(\"genperms\");\n    if (this.cmovesbyslice.length > 0) {\n      return;\n    }\n    const cmovesbyslice = [];\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.basefaces[i].centermass();\n          if (center.dist(this.facecentermass[kk]) < eps3) {\n            const bits = 1 << i | 1 << this.baseFaceCount;\n            const towards = this.markedface[bits];\n            const normal = this.baseplanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) < eps3) {\n              hii = hii2;\n            }\n            if (hii !== 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (; ; ) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps3) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        if (b.length > 2 && this.options.orientCenters && (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)) {\n          if (this.facecentermass[i].dist(\n            this.basefaces[this.getfaceindex(i)].centermass()\n          ) < eps3) {\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps3) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\"\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        if (b.length === 2 && this.options.orientCenters) {\n          const dir = this.facecentermass[i].dot(this.moveplanenormals[k]);\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (dir > 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k]\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist = [];\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n  getboundarygeometry() {\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals\n    };\n  }\n  getmovesets(k) {\n    const slices = this.moveplanesets[k].length;\n    let r = [];\n    if (this.parsedmovelist !== void 0) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j][0] === o[0] && newr[j][1] === o[1] && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    return r;\n  }\n  graybyori(cubie) {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ori === 1 && (this.options.grayCenters || !this.options.includeCenterOrbits) || ori === 2 && (this.options.grayEdges || !this.options.includeEdgeOrbits) || ori > 2 && (this.options.grayCorners || !this.options.includeCornerOrbits);\n  }\n  skipbyori(cubie) {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ori === 1 && !this.options.includeCenterOrbits || ori === 2 && !this.options.includeEdgeOrbits || ori > 2 && !this.options.includeCornerOrbits;\n  }\n  skipcubie(fi) {\n    return this.skipbyori(fi);\n  }\n  header(comment) {\n    return `${comment + copyright}\n${comment}\n`;\n  }\n  writegap() {\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = `M_${externalName(this.notationMapper, os.movenames[i])}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}:=${os.moveops[i].toPerm().inv().toGap()};`);\n      } else {\n        r.push(`${movename}:=${os.moveops[i].toPerm().toGap()};`);\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      `ip:=[${ip.map((_) => `[${_.map((__) => __ + 1).join(\",\")}]`).join(\",\")}];`\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n  writemathematica() {\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    r.push(`(* ${this.header(\"\").trim()} *)`);\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = `m${externalName(this.notationMapper, os.movenames[i])}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}=${os.moveops[i].toPerm().inv().toMathematica()};`);\n      } else {\n        r.push(`${movename}=${os.moveops[i].toPerm().toMathematica()};`);\n      }\n    }\n    r.push(`gen={${mvs.join(\",\")}};`);\n    return r.join(\"\\n\");\n  }\n  writeksolve(name = \"PuzzleGeometryPuzzle\") {\n    const od = this.getOrbitsDef(false);\n    return this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\");\n  }\n  getKPuzzleDefinition(fortwisty = true, includemoves = true) {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    internalDefinition.experimentalPuzzleDescription = this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n  getMoveFromBits(moverange, amount, inverted, axiscmoves, setmoves, movesetorder) {\n    const moveorbits = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] = (mperm[(ii + oinc) % mperm.length] - mperm[(ii + 1) % mperm.length] + 2 * this.orbitoris[setnum]) % this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array(oris[ii].length);\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n  omitSet(name) {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n  diffmvsets(a, b, slices, neg) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (a[i][0] + b[j][1] === slices && a[i][1] + b[j][0] === slices && a[i + 1] === b[j + 1]) {\n            found = true;\n          }\n        } else {\n          if (a[i][0] === b[j][0] && a[i][1] === b[j][1] && a[i + 1] === b[j + 1]) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n  // TODO: This is only public for testing; can we make it private again?\n  getOrbitsDef(fortwisty, includemoves = true) {\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames = [];\n    const setdefs = [];\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const slices = this.moveplanesets[k].length;\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (this.options.addRotations && (this.options.moveList || this.options.fixedPieceType !== null)) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps3) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps3) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (cmp.length !== mps[k].length || this.moveplanesets[k].length !== this.moveplanesets[found].length || this.diffmvsets(\n              cmp,\n              mps[k],\n              this.moveplanesets[found].length,\n              neg\n            )) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i][0] === moveset[j][0] && moveset[i][1] === moveset[j][1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i]\n        )\n      );\n    }\n    const solved = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i]\n        )\n      );\n    }\n    const movenames = [];\n    const forcenames = [];\n    const moves = [];\n    const isrots = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          let nameoverride;\n          let inverted = false;\n          if (this.parsedmovelist !== void 0) {\n            for (const parsedmove of this.parsedmovelist) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r2 = [];\n              if (parsedmove[4]) {\n                r2 = [parsedmove[2], parsedmove[3]];\n              } else {\n                r2 = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r2[0] === movebits[0] && r2[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k]\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n      isrots,\n      forcenames\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n  getScramble(n = 0) {\n    const od = this.getOrbitsDef(false);\n    return od.toKTransformationData(od.getScrambleTransformation(n));\n  }\n  getMovesAsPerms() {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n  showcanon(disp) {\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n  getsolved() {\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  getOrientationRotation(desiredRotation) {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1 = null;\n    let feature2 = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(`Could not find feature ${feature1name}`);\n    }\n    if (!feature2) {\n      throw new Error(`Could not find feature ${feature2name}`);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot.unproject(direction1).pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n  getInitial3DRotation() {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n  generate2dmapping(w = 800, h = 500, trim = 10, threed = false, twodshrink = 0.92) {\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a, n) {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = 2 * Math.PI / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length;\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0]\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos = {};\n    const bg = this.getboundarygeometry();\n    const edges2 = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff]\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0)\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(`Could not find first face name ${f0}`);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn]\n        ];\n        extendedges(edges2[f1], polyn);\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps3) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0)\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn, q) => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c\n        ];\n      }\n    };\n    return mappt2d;\n  }\n  generatesvg(w = 800, h = 500, trim = 10, threed = false) {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id, pts, color) {\n      return `<polygon id=\"${id}\" class=\"sticker\" style=\"fill: ${color}\" points=\"${pts.map((p) => `${p[0]} ${p[1]}`).join(\" \")}\"/>\n`;\n    }\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(`<title>${this.facenames[j][1]}</title>\n`);\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${cubieori}`;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${jj}`;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html = `<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\n<style type=\"text/css\"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n${svg.join(\n      \"\"\n    )}</svg>`;\n    return html;\n  }\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  get3d(options) {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie) ? options?.darkIgnoredOrbits ? \"#222222\" : \"#808080\" : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true\n          });\n        }\n      }\n    }\n    const grips = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1);\n    const g = (() => {\n      const irot = rot.invrot();\n      return (facenum, coords) => {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g }\n    };\n  }\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  getGeoNormal(geoname) {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        if (Math.abs(r[0]) < eps3 && Math.abs(r[2]) < eps3) {\n          r[0] = 0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return void 0;\n  }\n  getfaceindex(facenum) {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n  textForTwizzleExplorer() {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n  writeSchreierSims(tw) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n};\nvar PGNotation = class {\n  constructor(pg, od) {\n    __publicField(this, \"orbitNames\");\n    this.pg = pg;\n    this.orbitNames = od.orbitnames;\n  }\n  lookupMove(move) {\n    const mv = this.pg.parseMove(move);\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (parsedmove[1] === mv[1] && parsedmove[2] === mv[2] && parsedmove[3] === mv[3] && parsedmove[4] === mv[4]) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      void 0,\n      this.pg.movesetorders[mv[1]]\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n  remapKPuzzleDefinition(kpuzzleDefinition) {\n    return remapKPuzzleDefinition(kpuzzleDefinition, this.pg.notationMapper);\n  }\n};\nexport {\n  PUZZLE_BASE_SHAPES as EXPERIMENTAL_PUZZLE_BASE_SHAPES,\n  PUZZLE_CUT_TYPES as EXPERIMENTAL_PUZZLE_CUT_TYPES,\n  PGNotation as ExperimentalPGNotation,\n  PuzzleGeometry,\n  Quat,\n  getPG3DNamedPuzzles,\n  getPuzzleDescriptionString,\n  getPuzzleGeometryByDesc,\n  getPuzzleGeometryByName,\n  parseOptions,\n  parsePuzzleDescription,\n  schreierSims\n};\n"],"names":["FaceNameSwizzler","constructor","facenames","gripnames_arg","__publicField","this","gripnames","i","prefixFree","length","j","startsWith","setGripNames","names","splitByFaceNames","s","r","at","currentMatch","substr","Error","push","joinByFaceIndices","list","sep","join","spinmatch","userinput","longname","e1","e2","found","e","spinmatchv","endsWith","slice","unswizzle","upperCaseGrip","toUpperCase","g","NullMapper","notationToInternal","move","notationToExternal","FTONotationMapper","child","sw","family","innerLayer","outerLayer","Move","QuantumMove","amount","fam","substring","FaceRenamingMapper","internalNames","externalNames","convertString","grip","a","b","suffix","upper","isLowerCase","toLowerCase","convert","ngrip","MegaminxScramblingNotationMapper","Math","abs","NxNxNCubeMapper","slices","pyraminxFamilyMap","U","L","R","B","u","l","Uv","Lv","Rv","Bv","D","F","BL","BR","tetraminxFamilyMap","d","f","bl","br","pyraminxFamilyMapWCA","pyraminxExternalQuantumY","pyraminxInternalQuantumY","PyraminxNotationMapper","wcaHack","newFamilyWCA","newFamily","map","isIdentical","quantum","external","internal","Object","entries","TetraminxNotationMapper","super","skewbFamilyMap","UL","UR","ULv","Fv","URv","Dv","skewbExternalQuantumX","skewbInternalQuantumX","skewbInternalQuantumXPrime","skewbExternalQuantumY","skewbInternalQuantumY","skewbInternalQuantumYPrime","skewbExternalQuantumZ","skewbInternalQuantumZ","skewbInternalQuantumZPrime","SkewbNotationMapper","parseOptions","argv","argp","options","option","addRotations","allMoves","outerBlockMoves","vertexMoves","includeCornerOrbits","includeEdgeOrbits","fixedOrientation","includeCenterOrbits","excludeOrbits","split","moveList","optimizeOrbits","scrambleAmount","fixedPieceType","orientCenters","puzzleOrientation","JSON","parse","puzzleDescription","parsePuzzleDescription","PuzzleGeometryFullOptions","arguments","undefined","assign","zeroCache","iotaCache","zeros","n","c","Array","iota","lcm","t","m","gcd","Perm","_Perm","p","toString","mul","p2","rmul","inv","compareTo","toGap","cyc","seen","incyc","reverse","toMathematica","order","cs","PGOrbitDef","size","mod","reassemblySize","BigInt","factorial","lastGlobalDefinitionCounter","externalName","mapper","moveString","mv","fromString","mv2","_a","PGOrbitsDef","_PGOrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","isRotation","forcenames","toKTransformationData","ktransformationData","orbits","toKTransformationOrbitData","toKPatternData","kpatternData","toKPatternOrbitData","transformToKTransformationData","mp","describeSet","mvname","pd","perm","ori","toKsolve","name","result","appendDefinition","name2","doinv","toKPuzzleDefinition","includemoves","defaultPatternData","orbitName","numPieces","numOrientations","defaultPatternFrom","pieces","permutation","orientation","orientationDelta","moves","defaultPattern","optimize","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","union","keepori","duo","o","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","_","PGTransform","scramble","getScrambleTransformation","pool","floor","random","ri","rj","rm","PGOrbit","orimod","newPerm","newOri","equal","toPerm","identicalPieces","done","v","isIdentity","zeroOris","nextNew","reassign","ov","useVS","newori","ktransformationCache","orientationMod","PGTransformBase","internalMul","newOrbits","internalInv","orbit","perms","_PGTransform","mulScalar","_VisibleState","heads","ah","bh","PGPuzzles","skewb","helicopter","dino","pyramorphix","mastermorphix","pyraminx","tetraminx","megaminx","gigaminx","teraminx","petaminx","examinx","zetaminx","yottaminx","pentultimate","starminx","chopasaurus","FTO","octastar","icosamate","Redicosahedron","Icosaminx","eps","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","_Quat","q","dist","hypot","len","cross","dot","normalize","sqrt","makenormal","normalizeplane","sub","angle","acos","invrot","det3x3","a00","a01","a02","a10","a11","a12","a20","a21","a22","rotateplane","orthogonal","ab","ac","ad","pointrotation","unproject","rotatepoint","rotateface","det","side","x","cutface","inout","nface","kk","vk","r2","pt","cutfaces","faces","nfaces","faceside","sameplane","makecut","eps2","uniqueplanes","planerot","wasseen","getface","FactoredNumber","mult","multiply","schreierSims","disp","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","avgs","mults","cnt","lensum","avg","getsgs","Face","_Face","coords","get","off","centermass","sx","sy","rotate","rotateforward","FaceTree","_FaceTree","left","right","collect","arr","leftfirst","eps3","orientationDefaults","findelement","getPG3DNamedPuzzles","getPuzzleDescriptionString","puzzleName","PUZZLE_BASE_SHAPES","PUZZLE_CUT_TYPES","filter","Boolean","shape","cuts","cutType","distance","parseFloat","getPuzzleGeometryByDesc","desc","parsed","pg","PuzzleGeometry","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","inverted","movenameFamily","movenamePrefix","String","facename","toCoords","maxdist","toFaceCoords","verbosity","console","log","header","create","moveplanes","moveplanes2","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","baseFaceCount","net","colors","BB","C","A","E","BF","I","G","S","H","J","K","M","O","P","N","Q","baseface","zero","facenormal","edgenormal","vertexnormal","boundary","firstface","edgedistance","vertexdistance","cutplanes","intersects","sawface","sawedge","sawvertex","cut","normal","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","el","jj","otherfaces","facelist","facenametoindex","faceindextoname","neti","fi","ii","fn2","of","faceplane","midpoint","jjj","midpoint2","swizzler","oridata","markedface","oriprefs","fn","f1","f2","c1","c2","st","geonormals","edgename","vertexname","geonormalnames","rotation","moveplane","ft","tar","rval","stickersperface","simplerot","cm","finished","sortme","cm2","sort","rot","shortedge","addNotationMapper","setReidOrder","notationMapper","keyface","keyface2","sfcc","fromCharCode","moveplaneset","moveplanesets","dv","keyface3","findface","key","facelisthash","face2","facecentermass","project2d","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","rots","expandfaces","moveplanenormals","qnormal","moveplanenormal","goodnormal","sizes","moverotations","sizes2","movesetorders","movesetgeos","gtype","p0","neg","pos","geonormal","Map","suff","s2","set","facetocubie","facetoord","values","cmall","looplimit","mini","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","getfaceindex","cubiesetcubies","cubie","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","moverotation","tq","reidorder","reidmap","mask","charCodeAt","cubieset","fixedCubie","newmv","modified","stringToBlockMove","match","loslice","hislice","parseInt","amountstr","parseMove","bm","fullrotation","msi","geoname","firstgrip","parsemove","cmovesbyslice","center","towards","hiv","hii","hii2","qs","duplicatedFaces","duplicatedCubies","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","ocm","fi2","face1","face0","dir","parsedmovelist","clear","getboundarygeometry","getmovesets","parsedmove","msg","dep","newr","graybyori","grayCenters","grayEdges","grayCorners","skipbyori","skipcubie","comment","writegap","os","getOrbitsDef","mvs","movename","ip","__","writemathematica","trim","writeksolve","od","getKPuzzleDefinition","fortwisty","internalDefinition","experimentalPuzzleDescription","getMoveFromBits","moverange","setmoves","movesetorder","moveorbits","oris","slicecmoves","mperm","setnum","inc","oinc","lastId","omitSet","excludedSet","diffmvsets","setnames","setdefs","mps","addrot","moveset","hasrotation","sawone","nn","cmp","allbits","isrots","movesetgeo","movebits","nameoverride","mna","getScramble","getMovesAsPerms","showcanon","orders","commutes","permA","permB","curlev","nextlev","uniq","sti","nst","getsolved","getOrientationRotation","desiredRotation","feature1name","z1","direction1","feature2name","x2","y2","z2","direction2","feature1","feature2","feature1geoname","feature2geoname","gn","r1","getInitial3DRotation","basefacecount","orientationDescription","puzzleOrientations","generate2dmapping","w","threed","twodshrink","extendedges","cosa","sina","ndx","polyn","edges","minx","miny","maxx","maxy","f0","es","esi","min","max","xoff","yoff","geos","bg","edges2","initv","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","hix","hiy","sc2","mappt2d","xoff2","xmul","generatesvg","drawedges","id","pts","color","colormap","facegeo","facenum","fg","svg","cubieori","cubieord","get3d","stickers","darkIgnoredOrbits","stickerColors","ord","fcoords","rotdist","isDup","grips","coordinates","quantumMove","twodmapper","irot","bind","axis","textureMapper","getuv","getGeoNormal","divid","textForTwizzleExplorer","writeSchreierSims","tw","as","PGNotation","orbitNames","lookupMove","pgmv","remapKPuzzleDefinition","kpuzzleDefinition","externalDefinition","internalMoveName","transformationData","prefix","includes","externalPrefix","externalMoveName"],"sourceRoot":""}